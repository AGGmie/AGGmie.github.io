<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Grow with AGGmie</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://AGGmie.github.io/"/>
  <updated>2018-11-11T08:55:36.763Z</updated>
  <id>http://AGGmie.github.io/</id>
  
  <author>
    <name>AGGmie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Wechall write up part 3</title>
    <link href="http://AGGmie.github.io/2018/11/11/Wechall-write-up-part-3/"/>
    <id>http://AGGmie.github.io/2018/11/11/Wechall-write-up-part-3/</id>
    <published>2018-11-11T08:53:38.000Z</published>
    <updated>2018-11-11T08:55:36.763Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --> <p>wechall 第三部分writeup 虽然越来越难但是还是坚持被虐的AGGmie</p><a id="more"></a> <h3 id="Training-Crypto-Digraphs-Crypto-Training"><a href="#Training-Crypto-Digraphs-Crypto-Training" class="headerlink" title="Training: Crypto - Digraphs (Crypto, Training)"></a>Training: Crypto - Digraphs (Crypto, Training)</h3><p>拿图做的加密，概念很简单就是画了个26*26的表然后用a-z分别表示行列，例如aa表示就是第a行，第a列那个字符，然后去表里找就行了，但是这个表里面的字符我们不知道是怎么排的。这时候就开启我的魔幻解题之旅了。</p><p><strong>0x00</strong>:首先这是英文句子（什么屁话？）所以最后的两个字母我猜它肯定是加密的‘.’，然后成功找到了整篇文章所部分句子结束符也就是把部分句子和句子分开了。</p><p><strong>0x01</strong>:然后再次强调这是英文句子，所以我有个大胆的想法，每个结束符后跟着的句首都是大写字母，而除了句首以外的内容绝大部分都是小写字母，也就是整片文章小写字母&gt;&gt;大写字母。那么我们先破解小写字母，大写字母很容易就能猜出来</p><p><strong>0x03</strong>:第一句没有空格，证明是一个一长串的单词，我个英语废仔细搜寻我脑袋中适合放在这的这么老长的单词（没错这里瞎猜的。。）我想他应该是要恭喜我<del>喜当爹</del>，因此第一个单词应该是Congratulations，直接改下文章，爆出来第二个三个字母单词最后一位是U，再次猜是you得到结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibONGRATULATIONS. mgOU DoxmdRfhzoToxD TmxIS mhoxSSAGox SUmdmdoxSSjrULLfh. rgAS NOT TOO DIjrjrImdULT oxITmxoxRks usAS ITju rgoxLLks GOOD wlOfg. twNToxR TmxIS oeoxfhusORD AS SOLUTIONwk OfgzoRALoxjrzoNmxjr.</span><br></pre></td></tr></table></figure><p>为了分辨清楚明文密文，这里把明文小写字母都大写了，明文大写字母没有改还按密文显示。</p><p><strong>0x04</strong>：可以看到爆出来的部分明文还是有点靠谱的，找找有没有认识的单词，可以隐约发现个successful，开始改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibONGRATULATIONS. mgOU DECRfhzoTED TmxIS MESSAGE SUCCESSFULLfh. rgAS NOT TOO DIFFICULT EITmxERks usAS ITju rgELLks GOOD wlOfg. twNTER TmxIS oeEfhusORD AS SOLUTIONwk OfgzoRALEFzoNmxF.</span><br></pre></td></tr></table></figure><p><strong>0x05</strong>:  接下来很好看了，this message job decryption 这几个单词都能看出来大概了，再改一波：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibONGRATULATIONS. mgOU DECRYPTED THIS MESSAGE SUCCESSFULLY. rgAS NOT TOO DIFFICULT EITHERks usAS ITju rgELLks GOOD JOB. twNTER THIS oeEYusORD AS SOLUTIONwk OBPRALEFPNHF.</span><br></pre></td></tr></table></figure><p>我们要的flag已经出来了，没有改过来的就是剩下的大写字母和标点符号,和懒得再改的小写字母（逃~）了，我宣布魔幻解题之旅结束\OVO/</p><h3 id="Training-Math-Pyramid-Math-Training"><a href="#Training-Math-Pyramid-Math-Training" class="headerlink" title="Training: Math Pyramid (Math, Training)"></a>Training: Math Pyramid (Math, Training)</h3><p>这个emmm，反正不能用sqrt()它这一口气占了6个位置就剩仨位置也不够分啊，然后我们常说的根号几几几实际上是1/2次方也是0.5次方，椎体体积公式：</p><p><code>V=1/3Sh</code></p><p>V为体积，S为底面积，h为高（？？蜜汁开始讲初中数学）然后一顿计算之后导出来公式：</p><p> <code>a^3/18^0.5</code> </p><p>多了一位，小数因为整数位为0直接可以省略最后：</p><p><code>a^3/18^.5</code></p><p>无力吐槽.jpg</p><h3 id="hi-Math"><a href="#hi-Math" class="headerlink" title="hi (Math)"></a>hi (Math)</h3><p>整个流程在题干已经举例了，也就是我们要求第n秒的hi总数就是求2,3,4…n+1这个等差数列的和。直接上公式：</p><p><code>(2+time+1)*time)//2</code></p><p>但是有一个小点要注意，在python中‘/’表示的是浮点数除法，而’//‘表示的是整数除法，如果在这里用‘/’会被直接转换为科学计数法，导致精度出现问题，所以要用’//‘避免这个问题</p><p><strong>/</strong> 结果：</p><p><code>1.5472209893556454e+26</code></p><p><strong>//</strong>结果：</p><p><code>154722098935564539692256152</code></p><p>可以明显看到精度不同。</p><h3 id="No-Escape-Exploit-PHP-MySQL"><a href="#No-Escape-Exploit-PHP-MySQL" class="headerlink" title="No Escape (Exploit, PHP, MySQL)"></a>No Escape (Exploit, PHP, MySQL)</h3><p>源码中更新选票的操作如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$who = Common::getGet(<span class="string">'vote_for'</span>)</span><br><span class="line"> ......</span><br><span class="line">$query = <span class="string">"UPDATE noescvotes SET `$who`=`$who`+1 WHERE id=1"</span>;</span><br></pre></td></tr></table></figure><p>可以看到这里的who也是直接把变量放在这里没有做处理,直接构造payload:bill`=111 –+注意那个不是单引号。</p><h3 id="Stegano-Attachment-Stegano-Image-Training"><a href="#Stegano-Attachment-Stegano-Image-Training" class="headerlink" title="Stegano Attachment (Stegano, Image, Training)"></a>Stegano Attachment (Stegano, Image, Training)</h3><p>binwalk跑一下，发现里面藏了个.zip文件，直接改后缀解压缩得到结果</p><h3 id="Limited-Access-Exploit-HTTP"><a href="#Limited-Access-Exploit-HTTP" class="headerlink" title="Limited Access (Exploit, HTTP)"></a>Limited Access (Exploit, HTTP)</h3><p>.htaccess文件实际上是Apache服务器中的一个配置文件，可以实现相关目录下的网页配置。例如：文件夹密码保护、用户自动重定向、自定义错误页面、改变你的文件扩展名、封禁特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表，以及使用其他文件作为index文件等一些功能。 </p><p>这道题因为.htaccess文件的设置导致我们需要登录才能访问protected文件，但是我们看到.htaccess文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AuthUserFile .htpasswd</span><br><span class="line">AuthGroupFile /dev/null</span><br><span class="line">AuthName &quot;Authorization Required for the Limited Access Challenge&quot;</span><br><span class="line">AuthType Basic</span><br><span class="line">&lt;Limit GET&gt;</span><br><span class="line">require valid-user</span><br><span class="line">&lt;/Limit&gt;</span><br></pre></td></tr></table></figure><p>注意最后，只有在我们以GET请求访问页面的时候，才需要登录，因此我们只要使用POST请求来访问页面就可以绕过这个限制了。</p><h3 id="Training-Crypto-Substitution-I-Crypto-Training"><a href="#Training-Crypto-Substitution-I-Crypto-Training" class="headerlink" title="Training: Crypto - Substitution I (Crypto, Training)"></a>Training: Crypto - Substitution I (Crypto, Training)</h3><p>简单替换密码：简单替换密码是凯撒密码的变种，相对于凯撒密码每一位偏移量相同，简单替换密码则是采用不同的偏移量来进行加密，增加了破解难度。不过在英文中，每一位字母的出现频率是不同的，有人专门统计过字母出现的频率如下：</p><table><thead><tr><th><strong>a</strong></th><th>8.167%</th></tr></thead><tbody><tr><td><strong>b</strong></td><td>1.492%</td></tr><tr><td><strong>c</strong></td><td>2.782%</td></tr><tr><td><strong>d</strong></td><td>4.253%</td></tr><tr><td><strong>e</strong></td><td>12.702%</td></tr><tr><td><strong>f</strong></td><td>2.228%</td></tr><tr><td><strong>g</strong></td><td>2.015%</td></tr><tr><td><strong>h</strong></td><td>6.094%</td></tr><tr><td><strong>i</strong></td><td>6.966%</td></tr><tr><td><strong>j</strong></td><td>0.153%</td></tr><tr><td><strong>k</strong></td><td>0.772%</td></tr><tr><td><strong>l</strong></td><td>4.025%</td></tr><tr><td><strong>m</strong></td><td>2.406%</td></tr><tr><td><strong>n</strong></td><td>6.749%</td></tr><tr><td><strong>o</strong></td><td>7.507%</td></tr><tr><td><strong>p</strong></td><td>1.929%</td></tr><tr><td><strong>q</strong></td><td>0.095%</td></tr><tr><td><strong>r</strong></td><td>5.987%</td></tr><tr><td><strong>s</strong></td><td>6.327%</td></tr><tr><td><strong>t</strong></td><td>9.056%</td></tr><tr><td><strong>u</strong></td><td>2.758%</td></tr><tr><td><strong>v</strong></td><td>0.978%</td></tr><tr><td><strong>w</strong></td><td>2.360%</td></tr><tr><td><strong>x</strong></td><td>0.150%</td></tr><tr><td><strong>y</strong></td><td>1.974%</td></tr><tr><td><strong>z</strong></td><td>0.074%</td></tr></tbody></table><p>因此可以通过统计密文中字母的频率，对照字母频率表进行替换，然后在于字典比对进行破解，直接上解密网站：</p><p><a href="https://quipqiup.com/" target="_blank" rel="noopener">https://quipqiup.com/</a></p><h3 id="Zebra-Training-Encoding-Stegano"><a href="#Zebra-Training-Encoding-Stegano" class="headerlink" title="Zebra (Training, Encoding, Stegano)"></a>Zebra (Training, Encoding, Stegano)</h3><p>图片一打开就能看到🦓身上有个条形码，PS选手上线直接截取下来找个网站识别一下就可以了。</p><h3 id="Training-Crypto-Substitution-II-Crypto-Training"><a href="#Training-Crypto-Substitution-II-Crypto-Training" class="headerlink" title="Training: Crypto - Substitution II (Crypto, Training)"></a>Training: Crypto - Substitution II (Crypto, Training)</h3><p>这题解题思路后面和Training: Crypto - Digraphs (Crypto, Training)很像，前面稍微有些不同。我们在I里面已经知道简单替换密码的原理以及运用字母频率破解的方法，这里把加密空间扩大，和之前的一个扩大凯撒加密加密空间的手法是一样的。最终我们还是要以统计字符频率为切入点。解密前我们先整理一下线索：</p><p>1.这个明文是英文的，而且是英文句子。</p><p>2.英文句子的特点，都是英文字母且每个单词之间以空格区分。</p><p>ok，我们上来先统计一下每个密文字符的频率，以我拿到的密文为主，我统计出来的概率如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(&apos;5F&apos;, 0.1724137931034483), (&apos;8C&apos;, 0.08189655172413793), (&apos;8B&apos;, 0.07327586206896551), (&apos;9A&apos;, 0.07327586206896551), (&apos;21&apos;, 0.06465517241379311), (&apos;A7&apos;, 0.05172413793103448), (&apos;54&apos;, 0.04741379310344827), (&apos;5A&apos;, 0.04741379310344827), (&apos;07&apos;, 0.04741379310344827), (&apos;30&apos;, 0.04310344827586207), (&apos;6E&apos;, 0.034482758620689655), (&apos;C8&apos;, 0.02586206896551724), (&apos;5B&apos;, 0.02586206896551724), (&apos;3A&apos;, 0.02586206896551724), (&apos;0D&apos;, 0.02586206896551724), (&apos;1D&apos;, 0.02586206896551724), (&apos;AC&apos;, 0.021551724137931036), (&apos;D3&apos;, 0.017241379310344827), (&apos;F3&apos;, 0.017241379310344827), (&apos;E5&apos;, 0.01293103448275862), (&apos;7A&apos;, 0.01293103448275862), (&apos;32&apos;, 0.008620689655172414), (&apos;26&apos;, 0.008620689655172414), (&apos;FC&apos;, 0.008620689655172414), (&apos;6D&apos;, 0.004310344827586207), (&apos;D6&apos;, 0.004310344827586207), (&apos;9F&apos;, 0.004310344827586207), (&apos;34&apos;, 0.004310344827586207), (&apos;7F&apos;, 0.004310344827586207), (&apos;04&apos;, 0.004310344827586207)]</span><br></pre></td></tr></table></figure><p>稍微有点绝望的是，有很多字符概率是一样的，而且密文有点短，很可能有很大偏差。一个一个试会很麻烦。</p><p>但是我们知道的是单词与单词之间以空格分隔，那么空格出现的概率应该很高，所以大胆猜测一下5F就是空格。</p><p>另外几个高概率字符还是可以对比概率表的字符试一下，最后几个高概率对应如下：</p><p>8C：o</p><p>8B：e</p><p>9A：t</p><p>21：i</p><p>空格分开之后配合这些试出来的高概率字符可以很好的猜测出，没错，第一个单词又双叒叕是congratulations，嗯然后开始Training: Crypto - Digraphs (Crypto, Training)的套路就好了，所以这题关键点就是空格+高概率字符+瞎猜。</p><p>答完这题Score变成520 Global Rank变成6666了哈哈哈哈哈哈哈，我不管我要截图纪念一下！</p><p><img src="https://res.cloudinary.com/dt69vpleo/image/upload/v1541926308/5206666.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt; 
&lt;p&gt;wechall 第三部分writeup 虽然越来越难但是还是坚持被虐的AGGmie&lt;/p&gt;
    
    </summary>
    
      <category term="wechall" scheme="http://AGGmie.github.io/categories/wechall/"/>
    
    
      <category term="wechall" scheme="http://AGGmie.github.io/tags/wechall/"/>
    
  </entry>
  
  <entry>
    <title>WeChall write up part 2</title>
    <link href="http://AGGmie.github.io/2018/11/05/WeChall-write-up-part-2/"/>
    <id>http://AGGmie.github.io/2018/11/05/WeChall-write-up-part-2/</id>
    <published>2018-11-05T12:00:49.000Z</published>
    <updated>2018-11-06T08:23:00.807Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --> <p>wechall 第二部分writeup 在被血虐后的发X涂墙</p><a id="more"></a> <h3 id="PHP-0817-PHP-Exploit"><a href="#PHP-0817-PHP-Exploit" class="headerlink" title="PHP 0817 (PHP, Exploit)"></a>PHP 0817 (PHP, Exploit)</h3><p>先来点PHP预备知识，PHP在比较字符串和数字的时候，如果字符串为不可以转换为数字的字符组成的，那么就让其值默认为0，还有一些其他情况贴个学习链接：</p><p><a href="https://blog.csdn.net/auuuuuuuu/article/details/79621635" target="_blank" rel="noopener">https://blog.csdn.net/auuuuuuuu/article/details/79621635</a></p><p>所以在这里我们直接构造payload</p><p>payload: ?which=solution</p><p>就可以包含solution.php了。另外switch语句，如果case里面没有包含break，他是从他找到对应的那条开始一条一条执行的。所以从case 0开始case 1,case 2然后break退出。</p><h3 id="Training-Crypto-Transposition-I-Crypto-Training"><a href="#Training-Crypto-Transposition-I-Crypto-Training" class="headerlink" title="Training: Crypto - Transposition I (Crypto, Training)"></a>Training: Crypto - Transposition I (Crypto, Training)</h3><p>观察一下就发现两个字符为一对调换顺序，直接上脚本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cipherText = <span class="string">"oWdnreuf.lY uoc nar ae dht eemssga eaw yebttrew eh nht eelttre sra enic roertco drre . Ihtni koy uowlu dilekt  oes eoyrup sawsro don:wp cdhlhronch.p"</span></span><br><span class="line">plainText = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(cipherText),<span class="number">2</span>):</span><br><span class="line">    plainText += cipherText[i+<span class="number">1</span>] + cipherText[i]</span><br><span class="line"><span class="keyword">print</span> (plainText)</span><br></pre></td></tr></table></figure><h3 id="Training-Crypto-Caesar-II-Crypto-Training"><a href="#Training-Crypto-Caesar-II-Crypto-Training" class="headerlink" title="Training: Crypto - Caesar II (Crypto, Training)"></a>Training: Crypto - Caesar II (Crypto, Training)</h3><p>凯撒加密理论上加密空间为26个英文字母，这里把符号用ASCii表示，扩充了加密空间。通过偏移ASCii值达到加密，我这里直接暴力破解了偏移量，得出结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">file = open(<span class="string">'input.txt'</span>)</span><br><span class="line">inputList = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file.readlines():</span><br><span class="line">    inputList += line.split()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    outputStr = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> ASCii <span class="keyword">in</span> inputList:</span><br><span class="line">        outputStr += chr(int(ASCii,<span class="number">16</span>)+i)</span><br><span class="line">    print(outputStr)</span><br></pre></td></tr></table></figure><h3 id="Training-MySQL-I-MySQL-Exploit-Training"><a href="#Training-MySQL-I-MySQL-Exploit-Training" class="headerlink" title="Training: MySQL I (MySQL, Exploit, Training)"></a>Training: MySQL I (MySQL, Exploit, Training)</h3><p>十分基础的sql注入，对用户输入的用户名完全没做处理。所以在用户名输入 admin ‘ and 1=1 # 密码随便输入一个就可以注入成功</p><h3 id="Training-MySQL-II-MySQL-Exploit-Training"><a href="#Training-MySQL-II-MySQL-Exploit-Training" class="headerlink" title="Training: MySQL II (MySQL, Exploit, Training)"></a>Training: MySQL II (MySQL, Exploit, Training)</h3><p>这道题的和I的变化就是把账户和密码分开比对了，所以没办法使用简单的万能密码登录。但是可以发现用户名依然没有被处理直接放在查询语句。这里使用到的小技巧是sql union查询注入。先简单介绍一下union查询。</p><p>union查询是将两次查询结果合并为一次的查询方式。举个栗子：</p><p>例如一个查询为<code>SELECT username,password FROM users_1</code> 返回的值为</p><table><thead><tr><th>username</th><th>password</th></tr></thead><tbody><tr><td>admin</td><td>admin</td></tr><tr><td>AGGmie</td><td>23333</td></tr></tbody></table><p>使用union查询<code>SELECT username,password FROM users_1 union SELECT null,null</code></p><table><thead><tr><th>username</th><th>password</th></tr></thead><tbody><tr><td>admin</td><td>admin</td></tr><tr><td>AGGmie</td><td>23333</td></tr><tr><td>null</td><td>null</td></tr></tbody></table><p>可以发现他把两次查询的结果一起返回在一个集合中了。</p><p>union查询有两个要求：</p><p>1.所有查询列数必须相同，e.g.如果刚刚我union select null,null,null就会报错。</p><p>2.数据类型必须兼容。因此爆字段数时经常用null来避免不兼容（也有习惯用1,2,3的不过也有可能不兼容）</p><p>回到这道题：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$password = md5($password);</span><br><span class="line">       </span><br><span class="line">       $query = <span class="string">"SELECT * FROM users WHERE username='$username'"</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">false</span> === ($result = $db-&gt;queryFirst($query))) &#123;</span><br><span class="line">               <span class="keyword">echo</span> GWF_HTML::error(<span class="string">'Auth2'</span>, $chall-&gt;lang(<span class="string">'err_unknown'</span>), <span class="keyword">false</span>);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       <span class="comment">#############################</span></span><br><span class="line">       <span class="comment">### This is the new check ###</span></span><br><span class="line">       <span class="keyword">if</span> ($result[<span class="string">'password'</span>] !== $password) &#123;</span><br><span class="line">               <span class="keyword">echo</span> GWF_HTML::error(<span class="string">'Auth2'</span>, $chall-&gt;lang(<span class="string">'err_password'</span>), <span class="keyword">false</span>);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125; <span class="comment">#  End of the new code  ###</span></span><br><span class="line">       <span class="comment">#############################</span></span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       <span class="keyword">echo</span> GWF_HTML::message(<span class="string">'Auth2'</span>, $chall-&gt;lang(<span class="string">'msg_welcome_back'</span>, <span class="keyword">array</span>(htmlspecialchars($result[<span class="string">'username'</span>]))), <span class="keyword">false</span>);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> (strtolower($result[<span class="string">'username'</span>]) === <span class="string">'admin'</span>) &#123;</span><br><span class="line">               $chall-&gt;onChallengeSolved(GWF_Session::getUserID());</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>这段代码对于登录的判断如下：</p><p>先将用户提交的password MD5加密，然后执行查询语句，通过用户的username查询数据库中的password，如果查询出的password与用户输入的password不相等（都是MD5加密的）那么登录失败，如果相等，且username为admin，就成功登录admin账号。</p><p>所以我们可以对这句查询语句动动手脚：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$query = <span class="string">"SELECT * FROM users WHERE username='$username'"</span>;</span><br></pre></td></tr></table></figure><p>如果我们知道字段长，再把我们构造的username和password插到查询结果就大功告成了。 这是union查询登场!通过在username构造payload:<code>-1&#39; union select null,null,null#</code> 没有报错可以得到字段数为3,。</p><p>然后再把我们自己构造的admin登录名和密码插入到查询结果<code>-1&#39; union select null,&#39;admin&#39;,md5(&#39;admin&#39;)#</code></p><p>password中输入admin,可以发现登陆成功，这里要注意要payload里密码要md5加密。</p><h3 id="Training-Register-Globals-Exploit-PHP-Training"><a href="#Training-Register-Globals-Exploit-PHP-Training" class="headerlink" title="Training: Register Globals (Exploit, PHP, Training)"></a>Training: Register Globals (Exploit, PHP, Training)</h3><p>首先了解一下register_globals参数是做什么的，这个参数如果状态时打开的，所以传递进来的值都是全局变量。</p><p>举个栗子：</p><p>正常我们get或post提交什么信息应该都是通过<code>$_GET[&#39;xxx&#39;]</code> 或者 <code>$_POST[&#39;xxx&#39;]</code>来接受值的。如果register_globals开了，那么我们就可以直接通过<code>$xxx</code>来接受值。这就十分的危险了，也就是说用户可以通过get或者post直接改变变量的值。在这道题，我们阅读源代码可以看到下面这一段：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($login))</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">echo</span> GWF_HTML::message(<span class="string">'Register Globals'</span>, $chall-&gt;lang(<span class="string">'msg_welcome_back'</span>, <span class="keyword">array</span>(htmlspecialchars($login[<span class="number">0</span>]), htmlspecialchars($login[<span class="number">1</span>]))));</span><br><span class="line">        <span class="keyword">if</span> (strtolower($login[<span class="number">0</span>]) === <span class="string">'admin'</span>) &#123;                $chall-&gt;onChallengeSolved(GWF_Session::getUserID());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段中重要的就是如果<code>login[0]===‘admin’</code>,那么我们就可以以admin用户的身份登录了。又提到这里的register_globals是开启的，那就可以直接用GET请求把login[0]赋值为‘admin’就可以直接登录了</p><p>payload: ?login[0]=admin</p><h3 id="Training-Baconian-Stegano-Encoding-Crypto-Training"><a href="#Training-Baconian-Stegano-Encoding-Crypto-Training" class="headerlink" title="Training: Baconian (Stegano, Encoding, Crypto, Training)"></a>Training: Baconian (Stegano, Encoding, Crypto, Training)</h3><p>这道题是一个培根加密，实际上是一种二进制加密，具体加密方法如下：</p><p>​    明文 -&gt; 各个字母在字母表中位置 -&gt; 将位置转换为五位二进制 -&gt; 将二进制0改为A，1改为B -&gt; 用小写表示A大写表示B或者用正常字体表示A，粗体表示B -&gt; 密文</p><p>这道题只要把小写当初A（0）大写当成 B（1）然后二进制转十进制再转换ASCii码即可，但是注意文章中的空格及其他符号在转换时要跳过，否则结果会错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">file = open(<span class="string">"input.txt"</span>)</span><br><span class="line">stringList = file.readlines()[<span class="number">0</span>].split()</span><br><span class="line">string = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> stringList:</span><br><span class="line">    string += i</span><br><span class="line">newString = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> string:</span><br><span class="line">    <span class="keyword">if</span> i&gt;=<span class="string">'a'</span> <span class="keyword">and</span> i&lt;=<span class="string">'z'</span>:</span><br><span class="line">        newString +=<span class="string">'0'</span></span><br><span class="line">    <span class="keyword">elif</span> i&gt;=<span class="string">'A'</span> <span class="keyword">and</span> i&lt;=<span class="string">'Z'</span>:</span><br><span class="line">        newString +=<span class="string">'1'</span></span><br><span class="line">output = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(newString)<span class="number">-5</span>,<span class="number">5</span>):</span><br><span class="line">    num = newString[i:i+<span class="number">5</span>]</span><br><span class="line">    num = int(num,<span class="number">2</span>)</span><br><span class="line">    output += chr(num+<span class="number">97</span>)</span><br><span class="line"><span class="keyword">print</span> (output)</span><br></pre></td></tr></table></figure><h3 id="Training-GPG-Crypto-Training"><a href="#Training-GPG-Crypto-Training" class="headerlink" title="Training: GPG (Crypto, Training)"></a>Training: GPG (Crypto, Training)</h3><p>GPG是GNU Privacy Guard的缩写 ，可以生成密钥对来做到个人信息传输加密，和个人信息签名。GPG更详细的介绍见如下链接：</p><p><a href="https://www.gnupg.org/" target="_blank" rel="noopener">https://www.gnupg.org/</a></p><p><a href="https://wiki.ubuntu.com.cn/GPG/PGP" target="_blank" rel="noopener">https://wiki.ubuntu.com.cn/GPG/PGP</a></p><p>kali下默认安装了GPG，可以通过命令：<code>gpg --version</code>来查看linux中是否安装了GPG。</p><p><code>gpg --gen-key</code> </p><p>生成密钥对。</p><p><code>gpg --armor --output public-key.txt --export [用户ID]</code> </p><p>把公钥保存到文件public-key.txt 其中 –armor表示输出经 ASCII 封装 –output FILE表示输出的文件，–export导出密钥（公钥）其他命令可以通过<code>gpg --help</code>查看</p><p>在上传公钥后官方会发送一个加密的邮件让你解密后继续操作，这个邮件有点小坑，我用outlook接过来的格式全乱了，得自己调一下才可以解密。调整后格式如下：</p><p><img src="https://res.cloudinary.com/dt69vpleo/image/upload/v1541420716/Training_GPG_Crypto_Training.png" alt=""></p><p>然后执行 <code>gpg -d [文件名]</code>就可以解密了。然后访问解密出来的连接，就成功上传公钥了。解题就很简单了，也是解密个密文就可以了。（n+1次打成gdb我可能是有二进制手的心- -）</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt; 
&lt;p&gt;wechall 第二部分writeup 在被血虐后的发X涂墙&lt;/p&gt;
    
    </summary>
    
      <category term="wechall" scheme="http://AGGmie.github.io/categories/wechall/"/>
    
    
      <category term="wechall" scheme="http://AGGmie.github.io/tags/wechall/"/>
    
  </entry>
  
  <entry>
    <title>WeChall write up part 1</title>
    <link href="http://AGGmie.github.io/2018/10/31/WeChall-write-up-part-1/"/>
    <id>http://AGGmie.github.io/2018/10/31/WeChall-write-up-part-1/</id>
    <published>2018-10-31T10:37:44.000Z</published>
    <updated>2018-11-06T08:26:33.984Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --> <p>wechall 第一部分writeup 萌新入门求大佬赐教</p><a id="more"></a> <h3 id="Training-Get-Sourced-Training"><a href="#Training-Get-Sourced-Training" class="headerlink" title="Training: Get Sourced (Training)"></a>Training: Get Sourced (Training)</h3><p>右键查看源代码，拉到最下就可以看到答案</p><h3 id="Training-Stegano-I-Training-Stegano"><a href="#Training-Stegano-I-Training-Stegano" class="headerlink" title="Training: Stegano I (Training, Stegano)"></a>Training: Stegano I (Training, Stegano)</h3><p>直接右键图片另存为，打开</p><h3 id="Training-Crypto-Caesar-I-Crypto-Training"><a href="#Training-Crypto-Caesar-I-Crypto-Training" class="headerlink" title="Training: Crypto - Caesar I (Crypto, Training)"></a>Training: Crypto - Caesar I (Crypto, Training)</h3><p>凯撒加密，找网站解一下即可，看清楚点交solution别把一整句话都交上去啦</p><h3 id="Training-WWW-Robots-HTTP-Training"><a href="#Training-WWW-Robots-HTTP-Training" class="headerlink" title="Training: WWW-Robots (HTTP, Training)"></a>Training: WWW-Robots (HTTP, Training)</h3><p>大家可能一开始一脸懵逼连提交框在哪都找不到，其实hint就是提供的wiki页面介绍的知识。在网站的根目录一般会安放robots.txt文件用来提示网络爬虫什么该爬，什么不该爬。访问 <a href="http://www.wechall.net/robots.txt" target="_blank" rel="noopener">http://www.wechall.net/robots.txt</a> 就会发现一个禁止爬取的路径/challenge/training/www/robots/T0PS3CR3T/ 直接访问这个路径就可以啦</p><h3 id="Training-ASCII-Training-Encoding"><a href="#Training-ASCII-Training-Encoding" class="headerlink" title="Training: ASCII (Training, Encoding)"></a>Training: ASCII (Training, Encoding)</h3><p>ASCii值转字符，直接python写个小脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ASCiiList = [<span class="number">84</span>,<span class="number">104</span>,<span class="number">101</span>,<span class="number">32</span>,<span class="number">115</span>,<span class="number">111</span>,</span><br><span class="line">             <span class="number">108</span>,<span class="number">117</span>,<span class="number">116</span>,<span class="number">105</span>,<span class="number">111</span>,<span class="number">110</span>,</span><br><span class="line">             <span class="number">32</span>,<span class="number">105</span>,<span class="number">115</span>,<span class="number">58</span>,<span class="number">32</span>,<span class="number">109</span>,<span class="number">112</span>,</span><br><span class="line">             <span class="number">115</span>,<span class="number">108</span>,<span class="number">114</span>,<span class="number">112</span>,<span class="number">104</span>,<span class="number">101</span>,</span><br><span class="line">             <span class="number">109</span>,<span class="number">98</span>,<span class="number">110</span>,<span class="number">104</span>]</span><br><span class="line">str = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> ASCii <span class="keyword">in</span> ASCiiList:</span><br><span class="line">    <span class="keyword">print</span> (ASCii)</span><br><span class="line">    str += chr(int(ASCii))</span><br><span class="line">print(str)</span><br></pre></td></tr></table></figure><h3 id="Encodings-URL-Training-Encoding"><a href="#Encodings-URL-Training-Encoding" class="headerlink" title="Encodings: URL (Training, Encoding)"></a>Encodings: URL (Training, Encoding)</h3><p>URL编码，找网站解码，会给你一个URL，直接访问即可</p><h3 id="Prime-Factory-Training-Math"><a href="#Prime-Factory-Training-Math" class="headerlink" title="Prime Factory (Training, Math)"></a>Prime Factory (Training, Math)</h3><p>找到两个大于100万的素数并且每个素数每一位相加的结果也是素数。思路很简单，先判断他本身是不是素数，然后把每一位遍历相加，再判断是不是素数，为了方便每一位相加，我把数字按字符串保存，然后用int()函数再转成数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">IsPrime</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, num // <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> num % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">num = <span class="string">'1000000'</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">answer = <span class="string">''</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">if</span> IsPrime(int(num)):</span><br><span class="line">        SumNum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> num:</span><br><span class="line">            SumNum += int(char)</span><br><span class="line">        <span class="keyword">if</span> IsPrime(SumNum):</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            answer += num</span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">2</span>:</span><br><span class="line">        print(answer)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    num = str(int(num)+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="Training-Encodings-I-Training-Encoding"><a href="#Training-Encodings-I-Training-Encoding" class="headerlink" title="Training: Encodings I (Training, Encoding)"></a>Training: Encodings I (Training, Encoding)</h3><p>这题是把ASCii转换成了二进制，然后7比特位一组转换成十进制的ASCii值再转换成字符就可以了，官方给的JPK可以帮助你完成这个操作，我是自己直接写了个小脚本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">binaryString = <span class="string">"101010011010001101001111001101000001110100110010111110001110100010000011010011110011010000001101110101101110001011010011110100010000011001011101110110001111011111100100110010111001000100000110000111100111100011110100111010010101110010000010110011101111111010111100100100000111000011000011110011111001111101111101111111001011001000100000110100111100110100000110010111000011110011111100111100111110100110000111100101110100110010111100100101110"</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">string = <span class="string">""</span></span><br><span class="line">finallString = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> binaryString:</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    string += char</span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">7</span>:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        finallString += chr(int(string,<span class="number">2</span>))</span><br><span class="line">        string = <span class="string">""</span></span><br><span class="line"><span class="keyword">print</span> (finallString)</span><br></pre></td></tr></table></figure><p>​    </p><h3 id="Training-Programming-1-Training-Coding"><a href="#Training-Programming-1-Training-Coding" class="headerlink" title="Training: Programming 1 (Training, Coding)"></a>Training: Programming 1 (Training, Coding)</h3><p>1.337s之内返回，不知道有没有手快的大手子能手动搞定，我这个老年帕金森还是找py霸霸帮我吧</p><p>脚本就是收到返回值再发出去，记得抓下自己的cookies放上去。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">cookies = &#123;<span class="string">'WC'</span>:<span class="string">''</span>&#125;<span class="comment">#设置你自己的cookies</span></span><br><span class="line">response = requests.get(<span class="string">"http://www.wechall.net/challenge/training/programming1/index.php?action=request"</span>,cookies = cookies)</span><br><span class="line">requests.get(<span class="string">"http://www.wechall.net/challenge/training/programming1/index.php?answer=&#123;&#125;"</span>.format(response.text),cookies = cookies)</span><br></pre></td></tr></table></figure><h3 id="Training-Regex-Training-Regex"><a href="#Training-Regex-Training-Regex" class="headerlink" title="Training: Regex (Training, Regex)"></a>Training: Regex (Training, Regex)</h3><p>贴个学习链接 <a href="https://github.com/ziishaned/learn-regex/blob/master/README-cn.md" target="_blank" rel="noopener">https://github.com/ziishaned/learn-regex/blob/master/README-cn.md</a> ，正则表达式这东西还是靠多用才能记住。多练多查别死记硬背。(说的我好像会了似得，逃~</p><p>level 1:/^$/头尾相接就是空串</p><p>level 2：/^wechall$/ </p><p>level 3: 尝试1：/^wechall4?\.(tiff|png|jpg|bmp)$/  说我多了，然后尝试</p><p>  /^wechall4?.(?:tiff|png|jpg|bmp|gif) $/正确</p><p>level 4:/^(wechall4?)\.(?:tiff|png|jpg|bmp|gif)$/</p><p>这里说一下()和(?:)的区别，实际上他们都能匹配上东西，不过()是捕获并返回，而(?:)只捕获不返回，因此level4为了返回将wechall4?放在了()中，而level 3因为只捕获不返回，所以我的尝试1出错</p><h3 id="Training-PHP-LFI-Exploit-PHP-Training"><a href="#Training-PHP-LFI-Exploit-PHP-Training" class="headerlink" title="Training: PHP LFI (Exploit, PHP, Training)"></a>Training: PHP LFI (Exploit, PHP, Training)</h3><p>（吐槽：每次打开全英文的页面点开翻译，然后看着像是不知道哪位火星老哥给我翻译的中文就有一种想去狂背单词的欲望呢嘻嘻。悔不当初悔不当初呜呜呜，对不起我各位美女英语老师）</p><p>简单说一下本地文件包含漏洞就是可以让用户自己控制访问的路径，访问服务器本地的其他文件。再这里说个最常见的技巧。因为很多网站访问文件是不用你提供后缀的，那么问题来了即使有LFI，我想访问.php你给我定了个.txt后缀可咋整啊。这就用的PHP经常使用的技巧%00截断。因为PHP内核是C语言实现的（所以世界上最好的语言其实是？？）,C语言的字符串结束符是%00，所以如果你人为的输入%00就会把%00后面的内容截断了。就可以访问任意类型文件了。</p><p>payload :file=../../solution.php%00</p><p>所以为啥返回了两层啊？？我是瞎试试出来的..</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt; 
&lt;p&gt;wechall 第一部分writeup 萌新入门求大佬赐教&lt;/p&gt;
    
    </summary>
    
      <category term="wechall" scheme="http://AGGmie.github.io/categories/wechall/"/>
    
    
      <category term="wechall" scheme="http://AGGmie.github.io/tags/wechall/"/>
    
  </entry>
  
</feed>
