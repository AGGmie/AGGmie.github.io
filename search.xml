<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[WeChall write up part 2]]></title>
    <url>%2F2018%2F11%2F05%2FWeChall-write-up-part-2%2F</url>
    <content type="text"><![CDATA[wechall 第二部分writeup 在被血虐后的发X涂墙 PHP 0817 (PHP, Exploit)先来点PHP预备知识，PHP在比较字符串和数字的时候，如果字符串为不可以转换为数字的字符组成的，那么就让其值默认为0，还有一些其他情况贴个学习链接： https://blog.csdn.net/auuuuuuuu/article/details/79621635 所以在这里我们直接构造payload payload: ?which=solution 就可以包含solution.php了。另外switch语句，如果case里面没有包含break，他是从他找到对应的那条开始一条一条执行的。所以从case 0开始case 1,case 2然后break退出。 Training: Crypto - Transposition I (Crypto, Training)观察一下就发现两个字符为一对调换顺序，直接上脚本。 12345cipherText = "oWdnreuf.lY uoc nar ae dht eemssga eaw yebttrew eh nht eelttre sra enic roertco drre . Ihtni koy uowlu dilekt oes eoyrup sawsro don:wp cdhlhronch.p"plainText = ""for i in range(0,len(cipherText),2): plainText += cipherText[i+1] + cipherText[i]print (plainText) Training: Crypto - Caesar II (Crypto, Training)凯撒加密理论上加密空间为26个英文字母，这里把符号用ASCii表示，扩充了加密空间。通过偏移ASCii值达到加密，我这里直接暴力破解了偏移量，得出结果。 123456789file = open('input.txt')inputList = []for line in file.readlines(): inputList += line.split()for i in range(100): outputStr = '' for ASCii in inputList: outputStr += chr(int(ASCii,16)+i) print(outputStr) Training: MySQL I (MySQL, Exploit, Training)十分基础的sql注入，对用户输入的用户名完全没做处理。所以在用户名输入 admin ‘ and 1=1 # 密码随便输入一个就可以注入成功 Training: MySQL II (MySQL, Exploit, Training)这道题的和I的变化就是把账户和密码分开比对了，所以没办法使用简单的万能密码登录。但是可以发现用户名依然没有被处理直接放在查询语句。这里使用到的小技巧是sql union查询注入。先简单介绍一下union查询。 union查询是将两次查询结果合并为一次的查询方式。举个栗子： 例如一个查询为SELECT username,password FROM users_1 返回的值为 username password admin admin AGGmie 23333 使用union查询SELECT username,password FROM users_1 union SELECT null,null username password admin admin AGGmie 23333 null null 可以发现他把两次查询的结果一起返回在一个集合中了。 union查询有两个要求： 1.所有查询列数必须相同，e.g.如果刚刚我union select null,null,null就会报错。 2.数据类型必须兼容。因此爆字段数时经常用null来避免不兼容（也有习惯用1,2,3的不过也有可能不兼容） 回到这道题： 123456789101112131415161718192021222324$password = md5($password); $query = "SELECT * FROM users WHERE username='$username'"; if (false === ($result = $db-&gt;queryFirst($query))) &#123; echo GWF_HTML::error('Auth2', $chall-&gt;lang('err_unknown'), false); return false; &#125; ############################# ### This is the new check ### if ($result['password'] !== $password) &#123; echo GWF_HTML::error('Auth2', $chall-&gt;lang('err_password'), false); return false; &#125; # End of the new code ### ############################# echo GWF_HTML::message('Auth2', $chall-&gt;lang('msg_welcome_back', array(htmlspecialchars($result['username']))), false); if (strtolower($result['username']) === 'admin') &#123; $chall-&gt;onChallengeSolved(GWF_Session::getUserID()); &#125; 这段代码对于登录的判断如下： 先将用户提交的password MD5加密，然后执行查询语句，通过用户的username查询数据库中的password，如果查询出的password与用户输入的password不相等（都是MD5加密的）那么登录失败，如果相等，且username为admin，就成功登录admin账号。 所以我们可以对这句查询语句动动手脚： 1$query = "SELECT * FROM users WHERE username='$username'"; 如果我们知道字段长，再把我们构造的username和password插到查询结果就大功告成了。 这是union查询登场!通过在username构造payload:-1&#39; union select null,null,null# 没有报错可以得到字段数为3,。 然后再把我们自己构造的admin登录名和密码插入到查询结果-1&#39; union select null,&#39;admin&#39;,md5(&#39;admin&#39;)# password中输入admin,可以发现登陆成功，这里要注意要payload里密码要md5加密。 Training: Register Globals (Exploit, PHP, Training)首先了解一下register_globals参数是做什么的，这个参数如果状态时打开的，所以传递进来的值都是全局变量。 举个栗子： 正常我们get或post提交什么信息应该都是通过$_GET[&#39;xxx&#39;] 或者 $_POST[&#39;xxx&#39;]来接受值的。如果register_globals开了，那么我们就可以直接通过$xxx来接受值。这就十分的危险了，也就是说用户可以通过get或者post直接改变变量的值。在这道题，我们阅读源代码可以看到下面这一段： 123456if (isset($login))&#123; echo GWF_HTML::message('Register Globals', $chall-&gt;lang('msg_welcome_back', array(htmlspecialchars($login[0]), htmlspecialchars($login[1])))); if (strtolower($login[0]) === 'admin') &#123; $chall-&gt;onChallengeSolved(GWF_Session::getUserID()); &#125;&#125; 这一段中重要的就是如果login[0]===‘admin’,那么我们就可以以admin用户的身份登录了。又提到这里的register_globals是开启的，那就可以直接用GET请求把login[0]赋值为‘admin’就可以直接登录了 payload: ?login[0]=admin Training: Baconian (Stegano, Encoding, Crypto, Training)这道题是一个培根加密，实际上是一种二进制加密，具体加密方法如下： ​ 明文 -&gt; 各个字母在字母表中位置 -&gt; 将位置转换为五位二进制 -&gt; 将二进制0改为A，1改为B -&gt; 用小写表示A大写表示B或者用正常字体表示A，粗体表示B -&gt; 密文 这道题只要把小写当初A（0）大写当成 B（1）然后二进制转十进制再转换ASCii码即可，但是注意文章中的空格及其他符号在转换时要跳过，否则结果会错误。 1234567891011121314151617file = open("input.txt")stringList = file.readlines()[0].split()string = ''for i in stringList: string += inewString = ''for i in string: if i&gt;='a' and i&lt;='z': newString +='0' elif i&gt;='A' and i&lt;='Z': newString +='1'output = ''for i in range(0,len(newString)-5,5): num = newString[i:i+5] num = int(num,2) output += chr(num+97)print (output) Training: GPG (Crypto, Training)GPG是GNU Privacy Guard的缩写 ，可以生成密钥对来做到个人信息传输加密，和个人信息签名。GPG更详细的介绍见如下链接： https://www.gnupg.org/ https://wiki.ubuntu.com.cn/GPG/PGP kali下默认安装了GPG，可以通过命令：gpg --version来查看linux中是否安装了GPG。 gpg --gen-key 生成密钥对。 gpg --armor --output public-key.txt --export [用户ID] 把公钥保存到文件public-key.txt 其中 –armor表示输出经 ASCII 封装 –output FILE表示输出的文件，–export导出密钥（公钥）其他命令可以通过gpg --help查看 在上传公钥后官方会发送一个加密的邮件让你解密后继续操作，这个邮件有点小坑，我用outlook接过来的格式全乱了，得自己调一下才可以解密。调整后格式如下： 然后执行 gpg -d [文件名]就可以解密了。然后访问解密出来的连接，就成功上传公钥了。解题就很简单了，也是解密个密文就可以了。（n+1次打成gdb我可能是有二进制手的心- -）]]></content>
      <categories>
        <category>wechall</category>
      </categories>
      <tags>
        <tag>wechall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WeChall write up part 1]]></title>
    <url>%2F2018%2F10%2F31%2FWeChall-write-up-part-1%2F</url>
    <content type="text"><![CDATA[wechall 第一部分writeup 萌新入门求大佬赐教 Training: Get Sourced (Training)右键查看源代码，拉到最下就可以看到答案 Training: Stegano I (Training, Stegano)直接右键图片另存为，打开 Training: Crypto - Caesar I (Crypto, Training)凯撒加密，找网站解一下即可，看清楚点交solution别把一整句话都交上去啦 Training: WWW-Robots (HTTP, Training)大家可能一开始一脸懵逼连提交框在哪都找不到，其实hint就是提供的wiki页面介绍的知识。在网站的根目录一般会安放robots.txt文件用来提示网络爬虫什么该爬，什么不该爬。访问http://www.wechall.net/robots.txt就会发现一个禁止爬取的路径/challenge/training/www/robots/T0PS3CR3T/ 直接访问这个路径就可以啦 Training: ASCII (Training, Encoding)ASCii值转字符，直接python写个小脚本 12345678910ASCiiList = [84,104,101,32,115,111, 108,117,116,105,111,110, 32,105,115,58,32,109,112, 115,108,114,112,104,101, 109,98,110,104]str = ''for ASCii in ASCiiList: print (ASCii) str += chr(int(ASCii))print(str) Encodings: URL (Training, Encoding)URL编码，找网站解码，会给你一个URL，直接访问即可 Prime Factory (Training, Math)找到两个大于100万的素数并且每个素数每一位相加的结果也是素数。思路很简单，先判断他本身是不是素数，然后把每一位遍历相加，再判断是不是素数，为了方便每一位相加，我把数字按字符串保存，然后用int()函数再转成数字。 1234567891011121314151617181920def IsPrime(num): for i in range(2, num // 2 + 1): if num % i == 0: return False return Truenum = '1000000'count = 0answer = ''while True: if IsPrime(int(num)): SumNum = 0 for char in num: SumNum += int(char) if IsPrime(SumNum): count += 1 answer += num if count == 2: print(answer) break num = str(int(num)+1) Training: Encodings I (Training, Encoding)这题是把ASCii转换成了二进制，然后7比特位一组转换成十进制的ASCii值再转换成字符就可以了，官方给的JPK可以帮助你完成这个操作，我是自己直接写了个小脚本。 123456789101112binaryString = "101010011010001101001111001101000001110100110010111110001110100010000011010011110011010000001101110101101110001011010011110100010000011001011101110110001111011111100100110010111001000100000110000111100111100011110100111010010101110010000010110011101111111010111100100100000111000011000011110011111001111101111101111111001011001000100000110100111100110100000110010111000011110011111100111100111110100110000111100101110100110010111100100101110"count = 0string = ""finallString = ""for char in binaryString: count += 1 string += char if count == 7: count = 0 finallString += chr(int(string,2)) string = ""print (finallString) ​ Training: Programming 1 (Training, Coding)1.337s之内返回，不知道有没有手快的大手子能手动搞定，我这个老年帕金森还是找py霸霸帮我吧 脚本就是收到返回值再发出去，记得抓下自己的cookies放上去。 1234import requestscookies = &#123;'WC':''&#125;#设置你自己的cookiesresponse = requests.get("http://www.wechall.net/challenge/training/programming1/index.php?action=request",cookies = cookies)requests.get("http://www.wechall.net/challenge/training/programming1/index.php?answer=&#123;&#125;".format(response.text),cookies = cookies) Training: Regex (Training, Regex)贴个学习链接https://github.com/ziishaned/learn-regex/blob/master/README-cn.md，正则表达式这东西还是靠多用才能记住。多练多查别死记硬背。(说的我好像会了似得，逃~ level 1:/^$/头尾相接就是空串 level 2：/^wechall$/ level 3: 尝试1：/^wechall4?\.(tiff|png|jpg|bmp)$/ 说我多了，然后尝试 /^wechall4?.(?:tiff|png|jpg|bmp|gif) $/正确 level 4:/^(wechall4?)\.(?:tiff|png|jpg|bmp|gif)$/ 这里说一下()和(?:)的区别，实际上他们都能匹配上东西，不过()是捕获并返回，而(?:)只捕获不返回，因此level4为了返回将wechall4?放在了()中，而level 3因为只捕获不返回，所以我的尝试1出错 Training: PHP LFI (Exploit, PHP, Training)（吐槽：每次打开全英文的页面点开翻译，然后看着像是不知道哪位火星老哥给我翻译的中文就有一种想去狂背单词的欲望呢嘻嘻。悔不当初悔不当初呜呜呜，对不起我各位美女英语老师） 简单说一下本地文件包含漏洞就是可以让用户自己控制访问的路径，访问服务器本地的其他文件。再这里说个最常见的技巧。因为很多网站访问文件是不用你提供后缀的，那么问题来了即使有LFI，我想访问.php你给我定了个.txt后缀可咋整啊。这就用的PHP经常使用的技巧%00截断。因为PHP内核是C语言实现的（所以世界上最好的语言其实是？？）,C语言的字符串结束符是%00，所以如果你人为的输入%00就会把%00后面的内容截断了。就可以访问任意类型文件了。 payload :file=../../solution.php%00 所以为啥返回了两层啊？？我是瞎试试出来的..]]></content>
      <categories>
        <category>wechall</category>
      </categories>
      <tags>
        <tag>wechall</tag>
      </tags>
  </entry>
</search>
